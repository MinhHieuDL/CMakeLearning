8.1 Basic 
- Functions and macros in CMake have very similar characteristics to their same-named counterparts in C/C+
- Functions introduce a new scope and the function arguments become variables accessible inside the function 
body
- Macros, on the other hand, effectively paste their body into the point of the call and the macro arguments 
are substituted as simple string replacement
*** Syntax:
function(name [arg1 [arg2 [...]]])
    #funtion body
endfuntion()

macro(name [arg1 [arg2 [...]]])
    #macro body
endmacro()

8.2 Argument handling essentials
- The argument handling of functions and macros is the same except for one very important difference:
    + For functions, each argument is a CMake variable and has all the usual behaviors of a CMake variable. For example, 
    they can be tested in if() statements as variables
    + In comparison, macro arguments are string replacements, so whatever was used as the argument to the macro call
    is essentially pasted into wherever that argument appears in the macro body. If a macro argument is used in an if() statement,
    it would be treated as a string rather than a variable
- The value of that argument can be accessed in the function or macro body using the usual variable notation, even though macro 
arguments are not technically variables.
- Set of automatically defined variables (or variable-like names in the case of macros) which allow processing of arguments 
in addition to or instead of the named ones:
ARGC: total number of arguments passed to function (include named and unamed arguments)
ARGV: a list contain each of the arguments passed to the function (include named and unamed arguments)
ARGN: Like ARGV, except this only contains arguments beyond the named ones
- In addition to the above, each individual argument can be referenced with a name of the form ARGVx where x is the 
number of the argument (e.g. ARGV0, ARGV1, etc.).

8.3 Keyword arguments:
- Create something like:
    target_link_libraries(targetName
    <PRIVATE|PUBLIC|INTERFACE> item1 [item2 ...]
    [<PRIVATE|PUBLIC|INTERFACE> item3 [item4 ...]]
    ...
    )
- Use cmake_parse_arguments() command:
*** Syntax:
# Needed only for CMake 3.4 and earlier
include(CMakeParseArguments)

cmake_parse_arguments(
    prefix
    valuelessKeywords singleValueKeywords multiValueKeywords
    argsToParse...
)

# Available with CMake 3.7 or later, do not use in macros
cmake_parse_arguments(
    PARSE_ARGV startIndex
    prefix
    valuelessKeywords singleValueKeywords multiValueKeywords
)

- When cmake_parse_arguments() returns, variables may be defined whose names consist of the
specified prefix, an underscore and the name of the keyword they are associated with
- For example, with a prefix of ARG, the variable corresponding to a keyword named FOO would be ARG_FOO
- For each of the valuelessKeywords, the corresponding variable will be defined with the value TRUE if the
keyword is present or FALSE if it is not
- For each of the singleValueKeywords and multiValueKeywords, the corresponding variable will only be defined
if that keyword is present and a value is provided after the keyword
- The cmake_parse_arguments() command provides all leftover arguments as a list in the
variable <prefix>_UNPARSED_ARGUMENTS.
- With CMake 3.15 or later, the <prefix>_KEYWORDS_MISSING_VALUES variable will be populated with a list containing all
single- or multi-value keywords that were present but which did not have any value following
them

8.4 Returning Values
- Functions receive a copy of all variables from the calling scope
- Variables defined or modified inside a function have no effect on variables of the same name
outside the function
-  Macros, on the other hand, share the same variable scope as their caller and can therefore 
modify the caller’s variables directly.
8.4.1 Return Values From Functions
- With CMake 3.25 or later, a function can effectively return values by specifying variables to
propagate to the caller
- This is achieved using the PROPAGATE keyword with the return() command
- For each variable name listed after PROPAGATE, that variable will be updated in the calling scope to have the
same value as in the function at the point of the return() call
- If a propagated variable is unset in the function scope, it will also be unset in the calling scope
- A function should not normally dictate the name of variables to be set in the calling scope. Instead,
function arguments should be used to tell the function the names of variables to be set in the calling
scope
- The return() statement propagates variables to the calling scope. This means any block() statements
within the function do not prevent propagation to the function’s caller, but they will affect the
value of the variable(s) being propagate
- A function should not normally dictate the name of variables to be set in the calling scope. Instead,
function arguments should be used to tell the function the names of variables to be set in the calling
scope